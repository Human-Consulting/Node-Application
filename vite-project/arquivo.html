<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Prot√≥tipo ‚Äî 2 Minutes in Space (JS/Canvas)</title>
  <style>
    :root {
      --bg: #060914;
      --fg: #e6edf3;
      --muted: #98a1b3;
      --accent: #69d6ff;
      --danger: #ff6b6b;
      --warning: #ffd166;
      --success: #7bd88f;
      --panel: #0b1222;
    }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, 'Noto Sans', 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; }
    #ui { position: fixed; inset: 0; pointer-events: none; }
    #hud { position: absolute; top: 12px; left: 12px; background: rgba(11,18,34,.7); border: 1px solid #1a2540; border-radius: 12px; padding: 10px 12px; pointer-events: auto; backdrop-filter: blur(6px); }
    #hud .row { display: flex; gap: 10px; align-items: center; }
    #hud .pill { background: #0f1a33; border: 1px solid #1f2b4a; border-radius: 999px; padding: 4px 10px; font-size: 12px; color: var(--muted); }
    #hud strong { color: var(--fg); }
    #tips { position: absolute; bottom: 12px; left: 12px; font-size: 12px; color: var(--muted); opacity: .85; }
    #centerMsg { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; }
    #centerMsg h1 { margin: 0 0 8px; font-weight: 700; letter-spacing: .5px; }
    #centerMsg button { pointer-events: auto; cursor: pointer; background: var(--accent); color: #001219; border: none; padding: 10px 16px; border-radius: 10px; font-weight: 700; }

    canvas { display: block; width: 100vw; height: 100vh; }

    /* Controles mobile simples */
    #controls { position: fixed; right: 12px; bottom: 12px; display: grid; grid-template-columns: repeat(3, 56px); grid-auto-rows: 56px; gap: 8px; pointer-events: auto; }
    .btn { background: rgba(11,18,34,.7); border: 1px solid #1a2540; border-radius: 12px; color: var(--fg); display: flex; align-items: center; justify-content: center; user-select: none; touch-action: manipulation; }
    .btn:active { transform: translateY(1px); }
    .btn span { font-size: 20px; opacity: .9; }
    @media (min-width: 900px) { #controls { display: none; } }

    /* Indicadores de borda */
    .indicator { position: absolute; width: 0; height: 0; border-left: 8px solid transparent; border-right: 8px solid transparent; border-bottom: 16px solid var(--warning); filter: drop-shadow(0 0 4px rgba(255,209,102,.5)); }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div id="ui">
    <div id="hud">
      <div class="row" style="gap:14px">
        <div class="pill">Tempo: <strong id="time">0.0s</strong></div>
        <div class="pill">Dist√¢ncia: <strong id="dist">0</strong></div>
        <div class="pill">Velocidade: <strong id="speed">0</strong></div>
        <div class="pill">Asteroides: <strong id="astCnt">0</strong></div>
      </div>
    </div>
    <div id="tips">WASD / ‚Üë‚Üê‚Üí para pilotar ‚Ä¢ Shift = impulso ‚Ä¢ Espa√ßo = escudo (se dispon√≠vel)</div>
    <div id="centerMsg">
      <h1>2 Minutes (like) in Space ‚Äî Prot√≥tipo</h1>
      <p style="max-width:520px;margin:0 auto 14px;color:var(--muted)">Sobreviva desviando de asteroides e foguetes em um espa√ßo infinito gerado por <em>chunks</em>. Indicadores mostram perigos fora da tela. Use o bot√£o abaixo para come√ßar.</p>
      <button id="startBtn">Come√ßar</button>
    </div>
  </div>

  <!-- Controles mobile -->
  <div id="controls">
    <div class="btn" data-action="left"><span>‚ü≤</span></div>
    <div class="btn" data-action="thrust"><span>‚¨Ü</span></div>
    <div class="btn" data-action="right"><span>‚ü≤</span></div>
    <div class="btn" data-action="shield"><span>üõ°Ô∏è</span></div>
    <div class="btn" data-action="boost"><span>‚ö°</span></div>
  </div>

  <script>
  /******************** Utilidades ********************/
  const TAU = Math.PI * 2;
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function lerp(a,b,t){ return a + (b-a)*t; }
  // Hash + PRNG determin√≠stico por chunk
  function xmur3(str){ let h=1779033703^str.length; for(let i=0;i<str.length;i++){ h=Math.imul(h^str.charCodeAt(i),3432918353); h=h<<13|h>>>19; } return ()=>{ h=Math.imul(h^ (h>>>16), 2246822507); h=Math.imul(h^ (h>>>13), 3266489909); return (h^h>>>16)>>>0; }; }
  function mulberry32(a){ return function(){ let t = a += 0x6D2B79F5; t = Math.imul(t ^ t>>>15, t | 1); t ^= t + Math.imul(t ^ t>>>7, t | 61); return ((t ^ t>>>14) >>> 0) / 4294967296; } }
  function seededRng(seedStr){ const h = xmur3(seedStr)(); return mulberry32(h); }

  /******************** Canvas/Resize ********************/
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  function resize(){
    canvas.width = window.innerWidth * devicePixelRatio;
    canvas.height = window.innerHeight * devicePixelRatio;
  }
  window.addEventListener('resize', resize); resize();

  /******************** Estado do jogo ********************/
  const state = {
    running: false,
    time: 0,
    seed: Math.floor(Math.random()*1e9).toString(36),
    camera: { x: 0, y: 0 },
    ship: {
      x: 0, y: 0, vx: 0, vy: 0, angle: -Math.PI/2,
      radius: 18, thrust: 220, rotSpeed: 3.2, drag: 0.995,
      boost: 0, shield: 0, alive: true
    },
    inputs: { left:false, right:false, thrust:false, boost:false, shield:false },
    entities: [], // todos ativos (asteroides, foguetes, planetas ocasionais)
    chunks: new Map(),
    chunkSize: 1800,
    difficulty: 0,
    stats: { distance: 0 }
  };

  const TYPES = { AST: 1, ROCKET: 2, PLANET: 3 };

  function reset(){
    state.running = true;
    state.time = 0; state.difficulty = 0; state.entities.length = 0; state.chunks.clear();
    Object.assign(state.ship, { x:0,y:0,vx:0,vy:0,angle:-Math.PI/2, boost:0, shield: 0, alive:true });
    document.getElementById('centerMsg').style.display = 'none';
  }

  document.getElementById('startBtn').addEventListener('click', reset);

  /******************** Input ********************/
  const keys = new Set();
  const keyMap = {
    'ArrowLeft':'left','ArrowRight':'right','ArrowUp':'thrust','KeyA':'left','KeyD':'right','KeyW':'thrust','ShiftLeft':'boost','ShiftRight':'boost','Space':'shield'
  };
  window.addEventListener('keydown', e=>{ const k=keyMap[e.code]; if(k){ state.inputs[k]=true; e.preventDefault(); }});
  window.addEventListener('keyup', e=>{ const k=keyMap[e.code]; if(k){ state.inputs[k]=false; e.preventDefault(); }});

  // Mobile buttons
  document.querySelectorAll('#controls .btn').forEach(btn=>{
    const action = btn.dataset.action;
    const on = ()=> state.inputs[action] = true;
    const off = ()=> state.inputs[action] = false;
    btn.addEventListener('touchstart', (e)=>{ e.preventDefault(); on(); }, {passive:false});
    btn.addEventListener('touchend', (e)=>{ e.preventDefault(); off(); }, {passive:false});
    btn.addEventListener('mousedown', (e)=>{ e.preventDefault(); on(); });
    window.addEventListener('mouseup', off);
  });

  /******************** Gera√ß√£o por chunk ********************/
  function chunkKey(cx, cy){ return cx+','+cy; }
  function ensureChunk(cx, cy){
    const key = chunkKey(cx,cy);
    if(state.chunks.has(key)) return;
    const rng = seededRng(state.seed + '|' + key);

    const baseAst = 14 + Math.floor(rng()*6);
    const extra = Math.floor(state.difficulty*3);
    const astCount = baseAst + extra; // cresce com dificuldade

    const entities = [];
    // Asteroides
    for(let i=0;i<astCount;i++){
      const x = (cx + rng()) * state.chunkSize;
      const y = (cy + rng()) * state.chunkSize;
      const r = 18 + rng()*42;
      const speed = 10 + rng()* (40 + state.difficulty*60);
      const dir = rng()*TAU;
      entities.push({ type: TYPES.AST, x, y, vx: Math.cos(dir)*speed, vy: Math.sin(dir)*speed, r, rot: rng()*TAU, rotV: (rng()-0.5)*0.8 });
    }
    // Foguetes (teleguiados light)
    const rockets = (rng()<0.7 ? 1 : 0) + Math.floor(state.difficulty*2);
    for(let i=0;i<rockets;i++){
      const x = (cx + rng()) * state.chunkSize;
      const y = (cy + rng()) * state.chunkSize;
      entities.push({ type: TYPES.ROCKET, x, y, vx: 0, vy: 0, r: 10, angle: rng()*TAU, t:0 });
    }
    // Planetas ocasionais com gravidade
    if(rng() < 0.15){
      const x = (cx + 0.5 + (rng()-0.5)*0.6) * state.chunkSize;
      const y = (cy + 0.5 + (rng()-0.5)*0.6) * state.chunkSize;
      const R = 160 + rng()*220;
      entities.push({ type: TYPES.PLANET, x, y, r: R, mass: R*80 });
    }

    // Registra no mapa e adiciona nas entidades ativas
    state.chunks.set(key, true);
    state.entities.push(...entities);
  }

  function populateAround(x, y){
    const cs = state.chunkSize;
    const cx = Math.floor(x / cs);
    const cy = Math.floor(y / cs);
    for(let dy=-1; dy<=1; dy++){
      for(let dx=-1; dx<=1; dx++){
        ensureChunk(cx+dx, cy+dy);
      }
    }
  }

  /******************** F√≠sica/Jogabilidade ********************/
  function update(dt){
    if(!state.running || !state.ship.alive) return;
    state.time += dt;
    state.difficulty = Math.min(1, state.time / 120); // escala at√© 2 minutos

    const s = state.ship;
    // Input rota√ß√£o
    if(state.inputs.left) s.angle -= s.rotSpeed * dt;
    if(state.inputs.right) s.angle += s.rotSpeed * dt;
    // Impulso
    const thrust = (state.inputs.thrust ? s.thrust : 0) * (state.inputs.boost ? 1.8 : 1);
    if(thrust>0){ s.vx += Math.cos(s.angle) * thrust * dt; s.vy += Math.sin(s.angle) * thrust * dt; }

    // Arrasto leve
    s.vx *= s.drag; s.vy *= s.drag;

    // Atualiza nave
    s.x += s.vx * dt; s.y += s.vy * dt;

    // Popula chunks ao redor
    populateAround(s.x, s.y);

    // Intera√ß√µes com entidades
    const SCREEN_R = Math.hypot(canvas.width, canvas.height)/2 / devicePixelRatio + 1200;
    const toRemove = [];
    for(let i=0;i<state.entities.length;i++){
      const e = state.entities[i];
      if(e.type === TYPES.AST){
        e.x += e.vx * dt; e.y += e.vy * dt; e.rot += e.rotV * dt;
      } else if(e.type === TYPES.ROCKET){
        e.t += dt;
        // Busca leve na dire√ß√£o da nave com atraso
        const dx = s.x - e.x, dy = s.y - e.y;
        const targetA = Math.atan2(dy, dx);
        const diff = ((targetA - (e.angle||0) + Math.PI*3) % TAU) - Math.PI;
        e.angle = (e.angle||0) + diff * clamp(0.8*dt, 0, 1);
        const speed = lerp(80, 240, state.difficulty) + Math.min(e.t*20, 120);
        e.vx = Math.cos(e.angle) * speed; e.vy = Math.sin(e.angle) * speed;
        e.x += e.vx * dt; e.y += e.vy * dt;
      } else if(e.type === TYPES.PLANET){
        // gravidade sobre a nave
        const dx = e.x - s.x, dy = e.y - s.y; const d2 = dx*dx + dy*dy; const d = Math.sqrt(d2);
        if(d > 10){
          const g = (e.mass) / (d2+1);
          s.vx += (dx/d) * g * dt;
          s.vy += (dy/d) * g * dt;
        }
      }
      // Descarte se muito longe da c√¢mera
      if(Math.hypot(e.x - s.x, e.y - s.y) > SCREEN_R) toRemove.push(i);
    }
    // Remove longe demais (marcados)
    for(let j=toRemove.length-1;j>=0;j--){ state.entities.splice(toRemove[j],1); }

    // Colis√µes (nave vs asteroides/foguetes/planetas)
    const sr = s.radius;
    for(const e of state.entities){
      const dx = e.x - s.x, dy = e.y - s.y; const dist = Math.hypot(dx,dy);
      const R = (e.type===TYPES.PLANET? e.r*0.92 : (e.r||12));
      if(dist < sr + R){
        if(state.inputs.shield){ // colis√£o absorvida
          s.vx -= dx*0.2; s.vy -= dy*0.2; // empurra
        } else {
          s.alive = false; state.running = false;
          showGameOver();
          break;
        }
      }
    }

    // Estat√≠sticas
    state.stats.distance = Math.max(state.stats.distance, Math.floor(Math.hypot(s.x, s.y)));
  }

  function showGameOver(){
    const msg = document.getElementById('centerMsg');
    msg.style.display = 'block';
    msg.innerHTML = `<h1>Game Over</h1>
      <p style="max-width:520px;margin:0 auto 14px;color:var(--muted)">Voc√™ sobreviveu por <strong>${state.time.toFixed(1)}s</strong> e atingiu dist√¢ncia m√°xima de <strong>${state.stats.distance}u</strong>. Tente de novo!</p>
      <button id="startBtn">Recome√ßar</button>`;
    msg.querySelector('#startBtn').addEventListener('click', reset);
  }

  /******************** Render ********************/
  function draw(){
    const s = state.ship;
    // C√¢mera segue a nave
    state.camera.x = s.x; state.camera.y = s.y;

    // Fundo (estrelas parallax simples via seed + c√¢mera)
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const w = canvas.width, h = canvas.height;

    // Pintar um gradiente suave espacial
    const g = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, Math.max(w,h));
    g.addColorStop(0, '#0a0f1e'); g.addColorStop(1, '#050811');
    ctx.fillStyle = g; ctx.fillRect(0,0,w,h);

    // Estrelas
    const starRng = seededRng(state.seed + '|stars');
    for(let i=0;i<300;i++){
      const sx = (Math.floor((state.camera.x*0.1 + i*413) % w) + w) % w;
      const sy = (Math.floor((state.camera.y*0.1 + i*911) % h) + h) % h;
      const r = (starRng()*1.5 + 0.2) * devicePixelRatio;
      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      ctx.beginPath(); ctx.arc(sx, sy, r, 0, TAU); ctx.fill();
    }

    // Converte mundo->tela
    function toScreen(wx, wy){
      const x = (wx - state.camera.x) * devicePixelRatio + w/2;
      const y = (wy - state.camera.y) * devicePixelRatio + h/2;
      return [x,y];
    }

    // Desenhar entidades
    let astVisible = 0;
    for(const e of state.entities){
      const [x,y] = toScreen(e.x, e.y);
      if(x<-200 || x>w+200 || y<-200 || y>h+200){ continue; }
      if(e.type === TYPES.AST){ astVisible++; drawAsteroid(x,y,e.r*devicePixelRatio,e.rot); }
      else if(e.type === TYPES.ROCKET){ drawRocket(x,y,e); }
      else if(e.type === TYPES.PLANET){ drawPlanet(x,y,e.r*devicePixelRatio); }
    }

    // Desenhar nave
    const [sx, sy] = toScreen(s.x, s.y);
    drawShip(sx, sy, s.angle);

    // Indicadores para perigos fora da tela
    drawIndicators();

    // HUD
    document.getElementById('time').textContent = state.time.toFixed(1)+'s';
    const spd = Math.hypot(s.vx, s.vy);
    document.getElementById('speed').textContent = Math.round(spd).toString();
    document.getElementById('dist').textContent = state.stats.distance.toString();
    document.getElementById('astCnt').textContent = astVisible.toString();

    function drawShip(x,y,a){
      ctx.save();
      ctx.translate(x,y); ctx.rotate(a);
      ctx.lineWidth = 2*devicePixelRatio; ctx.strokeStyle = '#9fdcff';
      ctx.fillStyle = '#11293f';
      ctx.beginPath();
      ctx.moveTo(22*devicePixelRatio, 0);
      ctx.lineTo(-14*devicePixelRatio, -12*devicePixelRatio);
      ctx.lineTo(-8*devicePixelRatio, 0);
      ctx.lineTo(-14*devicePixelRatio, 12*devicePixelRatio);
      ctx.closePath();
      ctx.fill(); ctx.stroke();
      if(state.inputs.thrust){
        ctx.beginPath(); ctx.moveTo(-14*devicePixelRatio,0);
        ctx.lineTo(-26*devicePixelRatio, -6*devicePixelRatio);
        ctx.lineTo(-26*devicePixelRatio, 6*devicePixelRatio);
        ctx.closePath(); ctx.fillStyle = '#ffd166'; ctx.fill();
      }
      if(state.inputs.shield){
        ctx.beginPath(); ctx.arc(0,0, 26*devicePixelRatio, 0, TAU); ctx.strokeStyle = '#7bd88f'; ctx.lineWidth = 3*devicePixelRatio; ctx.stroke();
      }
      ctx.restore();
    }

    function drawAsteroid(x,y,r,rot){
      ctx.save(); ctx.translate(x,y); ctx.rotate(rot||0);
      ctx.fillStyle = '#2a3348'; ctx.strokeStyle = '#3f4b6b'; ctx.lineWidth = 2*devicePixelRatio;
      // forma irregular
      ctx.beginPath();
      const verts = 10; const wobble = 0.35;
      for(let i=0;i<verts;i++){
        const t = i/verts*TAU; const rr = r*(1-wobble + Math.random()*wobble);
        const px = Math.cos(t)*rr, py = Math.sin(t)*rr;
        if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.closePath(); ctx.fill(); ctx.stroke();
      ctx.restore();
    }

    function drawRocket(x,y,e){
      ctx.save(); ctx.translate(x,y); ctx.rotate(e.angle||0);
      ctx.fillStyle = '#5f87ff'; ctx.strokeStyle = '#a3b7ff'; ctx.lineWidth = 2*devicePixelRatio;
      ctx.beginPath();
      ctx.rect(-10*devicePixelRatio,-5*devicePixelRatio, 20*devicePixelRatio, 10*devicePixelRatio);
      ctx.fill(); ctx.stroke();
      // flare
      ctx.beginPath();
      ctx.moveTo(-10*devicePixelRatio, 0);
      ctx.lineTo(-18*devicePixelRatio, -6*devicePixelRatio);
      ctx.lineTo(-18*devicePixelRatio, 6*devicePixelRatio);
      ctx.closePath(); ctx.fillStyle = '#ffd166'; ctx.fill();
      ctx.restore();
    }

    function drawPlanet(x,y,r){
      const grd = ctx.createRadialGradient(x-r*0.4, y-r*0.4, r*0.2, x, y, r);
      grd.addColorStop(0,'#23395b'); grd.addColorStop(1,'#0f1a33');
      ctx.fillStyle = grd; ctx.beginPath(); ctx.arc(x,y,r,0,TAU); ctx.fill();
      ctx.strokeStyle = '#1a2540'; ctx.lineWidth = 3*devicePixelRatio; ctx.stroke();
    }

    function drawIndicators(){
      // Para cada entidade de perigo fora da tela, desenhar um tri√¢ngulo na borda apontando
      const margin = 24*devicePixelRatio;
      for(const e of state.entities){
        if(e.type === TYPES.PLANET) continue;
        const dx = e.x - state.camera.x, dy = e.y - state.camera.y;
        const sx = dx * devicePixelRatio + w/2; const sy = dy * devicePixelRatio + h/2;
        if(sx>=0 && sx<=w && sy>=0 && sy<=h) continue; // est√° vis√≠vel
        // Ponto clamped na tela
        const cx = clamp(sx, margin, w-margin);
        const cy = clamp(sy, margin, h-margin);
        const angle = Math.atan2(sy - clamp(sy, h/2, h/2), sx - clamp(sx, w/2, w/2)); // dire√ß√£o a partir do centro

        ctx.save(); ctx.translate(cx, cy); ctx.rotate(Math.atan2(sy - h/2, sx - w/2));
        ctx.fillStyle = (e.type===TYPES.ROCKET? '#ff6b6b' : '#ffd166');
        ctx.beginPath();
        ctx.moveTo(0, -12*devicePixelRatio);
        ctx.lineTo(-8*devicePixelRatio, 12*devicePixelRatio);
        ctx.lineTo(8*devicePixelRatio, 12*devicePixelRatio);
        ctx.closePath(); ctx.fill();
        ctx.restore();
      }
    }
  }

  /******************** Loop ********************/
  let last=performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now-last)/1000); // travar a 30ms m√°x p/ estabilidade
    last=now;
    if(state.running) update(dt);
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // Start hints
  draw();
  </script>
</body>
</html>
